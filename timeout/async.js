/**
 * JS中的同步编程和异步编程
 *      JS是单线程的（一次只能执行一个任务，当前任务没有完成，下面的任务是不进行处理的）
 * 同步编程（sync）
 *      任务是按照顺序一件件的完成的。当前任务没有完成下面的任务不进行处理。
 * 异步编程（async） 
 *      当前任务在等待执行的时候，我们不去执行，继续完成下面的任务，当下面的任务完成后，而且也到达等待时间了，才去完成当前的任务。
 *  JS中的异步编程有下面几种情况
 *      1） 定时器都是异步编程
 *      2） 所有的事件绑定也是异步编程
 *      3） AJAX中的异步编程
 *      4） 有些人把回调函数当做异步编程（这个理解起来比较迁强）
 *  其余的都是同步编程
 * 
 */

/**
 * 同步编程以及如何验证当前任务消耗的时间或者性能
 * 输出结果：
 * no
 * ok
 */
//  var startTime = new Date();
//  for (let i = 0; i < 100000; i++) {
//      if(i===99999)
//       console.log('no');
//  }
//  console.log(new Date() - startTime);
//  console.log('ok');


/**
 * ok 永远不能输出
 * 在真实项目中我们要避免出现死循环：因为循环是同步编程，当前循环无法结束说明任务没完成，后续的任务操作都不执行
 */
//  while(1===1){

//  }
//  console.log('ok');


/**
 * 输出结果：
 *  0
 *  1
 * 定时器包括2部分  创建定时器和等待多长时间做事
 */
// var n = 0;
// setTimeout(function(){
//     n++;
//     console.log(n);
// },1000);
// console.log(n);

/**
 * 同步异步编程的核心原理
 * JS中有两个任务队列（存放任务列表的空间就是任务队列）：
 * 1. 主任务队列：同步执行任务（从上到下依次执行）
 * 2. 等待任务队列：异步执行任务
 */

/**
 * 那个时间先到那个就先执行.
 * 当主任务队列中的任务都完成了，在等待任务队列中，找到已经到达时间的任务（那个先到，先找哪一个，同时到的，按照创建顺序来），
 * 把等待任务列表中的任务拿到主任务队列中执行，
 * 当前这个任务完成后，在到等待中去找其他的任务。
 * 
 * 输出结果：
 * 4
 * 2
 * 3
 * 1
 */
//  setTimeout(function(){
//      console.log(1);

//  },50);

//  setTimeout(function(){
//     console.log(2);

// },10);

// setTimeout(function(){
//     console.log(3);

// },30);
// var timer = new Date();
//  for (let i = 0; i < 10000000; i++) {
//      //需要600MS~700MS  
//  }
// console.log(new Date() - timer);

//  console.log(4);







